{% extends "base.html" %}    

{% block content %}
<div class="container">
<h2>Edit Bookmark</h2>
<form action="" method="post" novalidate>
        {{ form.hidden_tag() }}
        <p>
            {{ form.title.label }}<br>
            {{ form.title(size=32, id="title") }}
            {% if form.title.errors %}
            <div class="field-errors">
                {% for error in form.title.errors %}
                <span class="error">{{ error }}</span>
                {% endfor %}
            </div>
            {% endif %}
        </p>
        <p>
            {{ form.url.label }}<br>
            {{ form.url(size=32, id="url") }}
            {% if form.url.errors %}
            <div class="field-errors">
                {% for error in form.url.errors %}
                <span class="error">{{ error }}</span>
                {% endfor %}
            </div>
            {% endif %}
        </p>
        <p>
            {{ form.description.label }}<br>
            {{ form.description(size=32, id="description") }}
            {% if form.description.errors %}
            <div class="field-errors">
                {% for error in form.description.errors %}
                <span class="error">{{ error }}</span>
                {% endfor %}
            </div>
            {% endif %}
        </p>
        <p>
            {{ form.tags.label }}<br>
            <div class="tag-input-container">
                {{ form.tags(size=32, id="tags-input") }}
                <div id="tag-suggestions" class="tag-suggestions"></div>
            </div>
        </p>
        <p>{{ form.submit() }}</p>
    </form>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const tagsInput = document.getElementById('tags-input');
    const suggestionsDiv = document.getElementById('tag-suggestions');
    let allTags = [];
    
    // Fetch all available tags
    fetch('/api/tags')
        .then(response => response.json())
        .then(tags => {
            allTags = tags;
        });
    
    // Handle input events
    tagsInput.addEventListener('input', function() {
        const currentValue = this.value;
        const cursorPos = this.selectionStart;
        
        // Find the current tag being typed
        const beforeCursor = currentValue.substring(0, cursorPos);
        const lastCommaIndex = beforeCursor.lastIndexOf(',');
        const currentTag = beforeCursor.substring(lastCommaIndex + 1).trim();
        
        if (currentTag.length >= 1) {
            // Filter matching tags
            const matches = allTags.filter(tag => 
                tag.toLowerCase().includes(currentTag.toLowerCase()) &&
                !getCurrentTags(currentValue).includes(tag)
            ).slice(0, 5); // Show max 5 suggestions
            
            showSuggestions(matches, currentTag);
        } else {
            hideSuggestions();
        }
    });
    
    function getCurrentTags(value) {
        return value.split(',').map(tag => tag.trim()).filter(tag => tag);
    }
    
    function showSuggestions(matches, currentTag) {
        if (matches.length === 0) {
            hideSuggestions();
            return;
        }
        
        suggestionsDiv.innerHTML = matches.map(tag => 
            `<div class="tag-suggestion" data-tag="${tag}">${tag}</div>`
        ).join('');
        
        suggestionsDiv.style.display = 'block';
        
        // Add click handlers
        suggestionsDiv.querySelectorAll('.tag-suggestion').forEach(suggestion => {
            suggestion.addEventListener('click', function() {
                selectTag(this.dataset.tag);
            });
        });
    }
    
    function hideSuggestions() {
        suggestionsDiv.style.display = 'none';
    }
    
    function selectTag(selectedTag) {
        const currentValue = tagsInput.value;
        const cursorPos = tagsInput.selectionStart;
        const beforeCursor = currentValue.substring(0, cursorPos);
        const afterCursor = currentValue.substring(cursorPos);
        
        const lastCommaIndex = beforeCursor.lastIndexOf(',');
        const newValue = beforeCursor.substring(0, lastCommaIndex + 1) + 
                        (lastCommaIndex >= 0 ? ' ' : '') + 
                        selectedTag + ', ' + afterCursor;
        
        tagsInput.value = newValue;
        tagsInput.focus();
        
        // Position cursor after the selected tag
        const newCursorPos = (lastCommaIndex >= 0 ? lastCommaIndex + 2 : 0) + selectedTag.length + 2;
        tagsInput.setSelectionRange(newCursorPos, newCursorPos);
        
        hideSuggestions();
    }
    
    // Hide suggestions when clicking outside
    document.addEventListener('click', function(e) {
        if (!tagsInput.contains(e.target) && !suggestionsDiv.contains(e.target)) {
            hideSuggestions();
        }
    });
});

// Form validation
function validateForm() {
    const title = document.getElementById('title').value.trim();
    const url = document.getElementById('url').value.trim();
    const description = document.getElementById('description').value.trim();
    
    // Clear previous errors
    document.querySelectorAll('.client-error').forEach(error => error.remove());
    
    let isValid = true;
    
    // Validate title
    if (!title) {
        showClientError('title', 'Title is required');
        isValid = false;
    } else if (title.length > 200) {
        showClientError('title', 'Title must be less than 200 characters');
        isValid = false;
    }
    
    // Validate URL
    if (!url) {
        showClientError('url', 'URL is required');
        isValid = false;
    } else {
        try {
            new URL(url);
        } catch {
            showClientError('url', 'Please enter a valid URL');
            isValid = false;
        }
    }
    
    // Validate description
    if (!description) {
        showClientError('description', 'Description is required');
        isValid = false;
    } else if (description.length > 1000) {
        showClientError('description', 'Description must be less than 1000 characters');
        isValid = false;
    }
    
    return isValid;
}

function showClientError(fieldName, message) {
    const field = document.getElementById(fieldName);
    const errorDiv = document.createElement('div');
    errorDiv.className = 'field-errors';
    errorDiv.innerHTML = `<span class="error client-error">${message}</span>`;
    field.parentNode.appendChild(errorDiv);
}

// Add form validation on submit
document.querySelector('form').addEventListener('submit', function(e) {
    if (!validateForm()) {
        e.preventDefault();
    }
});

// Add real-time validation
['title', 'url', 'description'].forEach(fieldName => {
    const field = document.getElementById(fieldName);
    if (field) {
        field.addEventListener('blur', validateForm);
    }
});
</script>

    {% endblock %}